{"version":3,"file":"Exports.js","sourceRoot":"","sources":["../src/Exports.ts"],"names":[],"mappings":";;;;;AAAA,wEAAkD;AAUlD;IAAA;IA8BA,CAAC;IA3BG,iDAA6B,GAA7B,UAA8B,QAAwC;QAClE,IAAG,QAAQ,YAAY,8BAA8B;YACjD,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;;YAE9B,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;IACzF,CAAC;IAED,+DAA2C,GAA3C,UAAmE,IAAO;QACtE,IAAG,CAAC,IAAI,CAAC,aAAa;YAClB,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC;QAE9E,IAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,mCAAmC,CAAC,IAAI,CAAC,CAAC;gCAC3E,YAAY;YAChB,IAAM,QAAQ,GAAG,oBAAU,CAAC,GAAG,EAAE,CAAC;YAClC,OAAK,aAAa,CAAC,kCAAkC,CAAC,YAAY,EAAE,cAAM,OAAA,QAAQ,EAAR,CAAQ,CAAC,CAAC;QACxF,CAAC;;QAHD,KAAwB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa;YAAjC,IAAI,YAAY,sBAAA;oBAAZ,YAAY;SAGnB;IACL,CAAC;IAED,uCAAmB,GAAnB,UAA2C,IAAO;QAC9C,IAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC1D,OAAO,QAAe,CAAC;IAC3B,CAAC;IAED,mCAAe,GAAf,UAAuC,IAAO;QAC1C,IAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC1D,OAAO,QAAe,CAAC;IAC3B,CAAC;IACL,gBAAC;AAAD,CAAC,AA9BD,IA8BC;AA9BY,8BAAS;AAgCtB;IAAA;IAIA,CAAC;IAAD,qCAAC;AAAD,CAAC,AAJD,IAIC;AAJqB,wEAA8B","sourcesContent":["import Substitute from '@fluffy-spoon/substitute';\r\nimport { ObjectSubstitute, OmitProxyMethods } from '@fluffy-spoon/substitute/dist/src/Transformations';\r\n\r\nexport type Constructor<T = any> = { new(...args): T };\r\n\r\nexport interface IAutofaker {\r\n    useInversionOfControlProvider(provider: InversionOfControlRegistration): void;\r\n    registerFakesForConstructorParameterTypesOf<T extends Constructor>(type: T): void;\r\n}\r\n\r\nexport class Autofaker implements IAutofaker {\r\n    private _registration: InversionOfControlRegistration;\r\n\r\n    useInversionOfControlProvider(provider: InversionOfControlRegistration) {\r\n        if(provider instanceof InversionOfControlRegistration)\r\n            this._registration = provider;\r\n        else\r\n            throw new Error('The given value is not a valid Inversion of Control provider.');\r\n    }\r\n\r\n    registerFakesForConstructorParameterTypesOf<T extends Constructor>(type: T) {\r\n        if(!this._registration)\r\n            throw new Error('An Inversion of Control provider must be set up first.');\r\n        \r\n        const argumentTypes = this._registration.getConstructorArgumentTypesForClass(type);\r\n        for(let argumentType of argumentTypes) {\r\n            const instance = Substitute.for();\r\n            this._registration.registerTypeAsInstanceFromAccessor(argumentType, () => instance);\r\n        }\r\n    }\r\n\r\n    resolveFakeInstance<T extends Constructor>(type: T): ObjectSubstitute<OmitProxyMethods<T>, T> {\r\n        const instance = this._registration.resolveInstance(type);\r\n        return instance as any;\r\n    }\r\n\r\n    resolveInstance<T extends Constructor>(type: T): T {\r\n        const instance = this._registration.resolveInstance(type);\r\n        return instance as any;\r\n    }\r\n}\r\n\r\nexport abstract class InversionOfControlRegistration {\r\n    abstract registerTypeAsInstanceFromAccessor(type: Constructor<any>, accessor: () => any): void;\r\n    abstract getConstructorArgumentTypesForClass<T extends Constructor>(type: T): Array<Constructor>;\r\n    abstract resolveInstance<T extends Constructor>(type: T): T;\r\n}"]}