{"version":3,"file":"Exports.js","sourceRoot":"","sources":["../src/Exports.ts"],"names":[],"mappings":";;AAEA;IAAA;IA8BA,CAAC;IA1BG,uBAAG,GAAH,UAAI,QAAsD;QACtD,IAAG,QAAQ,YAAY,8BAA8B;YACjD,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;aAC7B,IAAG,QAAQ,YAAY,aAAa;YACrC,IAAI,CAAC,cAAc,GAAG,QAAQ,CAAC;;YAE/B,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;IACpE,CAAC;IAED,+DAA2C,GAA3C,UAAmE,IAAO;QACtE,IAAG,CAAC,IAAI,CAAC,aAAa;YAClB,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;QAE/E,IAAG,CAAC,IAAI,CAAC,cAAc;YACnB,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;QAE3D,IAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,mCAAmC,CAAC,IAAI,CAAC,CAAC;QACnF,KAAwB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;YAAnC,IAAI,YAAY,sBAAA;YAChB,IAAM,qBAAqB,GAAG,IAAI,CAAC,cAAc,CAAC,6BAA6B,CAAC,YAAY,CAAC,CAAC;YAC9F,KAA+B,UAAqB,EAArB,+CAAqB,EAArB,mCAAqB,EAArB,IAAqB,EAAE;gBAAlD,IAAI,mBAAmB,8BAAA;gBACvB,IAAI,CAAC,aAAa,CAAC,kCAAkC,CACjD,mBAAmB,CAAC,IAAI,EACxB,mBAAmB,CAAC,QAAQ,CAAC,CAAC;aACrC;SACJ;IACL,CAAC;IACL,gBAAC;AAAD,CAAC,AA9BD,IA8BC;AA9BY,8BAAS;AAgCtB;IAAA;IAGA,CAAC;IAAD,qCAAC;AAAD,CAAC,AAHD,IAGC;AAHqB,wEAA8B;AAKpD;IAAA;IAEA,CAAC;IAAD,oBAAC;AAAD,CAAC,AAFD,IAEC;AAFqB,sCAAa;AAInC;IAII,6BACY,KAAkB,EAClB,SAAoB;QADpB,UAAK,GAAL,KAAK,CAAa;QAClB,cAAS,GAAT,SAAS,CAAW;IAGhC,CAAC;IARD,sBAAW,qCAAI;aAAf,cAAoB,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;;;OAAA;IACxC,sBAAW,yCAAQ;aAAnB,cAAwB,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;;;OAAA;IAQpD,0BAAC;AAAD,CAAC,AAVD,IAUC;AAVY,kDAAmB","sourcesContent":["type Constructor<T = any> = { new(...args): T };\r\n\r\nexport class Autofaker {\r\n    private _registration: InversionOfControlRegistration;\r\n    private _fakeGenerator: FakeGenerator;\r\n\r\n    use(provider: InversionOfControlRegistration|FakeGenerator) {\r\n        if(provider instanceof InversionOfControlRegistration)\r\n            this._registration = provider;\r\n        else if(provider instanceof FakeGenerator)\r\n            this._fakeGenerator = provider;\r\n        else\r\n            throw new Error('The given value is not a valid provider.');\r\n    }\r\n\r\n    registerFakesForConstructorParameterTypesOf<T extends Constructor>(type: T) {\r\n        if(!this._registration)\r\n            throw new Error('An Inversion of Control registration must be specified.');\r\n        \r\n        if(!this._fakeGenerator)\r\n            throw new Error('A fake generator must be specified.');\r\n        \r\n        const argumentTypes = this._registration.getConstructorArgumentTypesForClass(type);\r\n        for(let argumentType of argumentTypes) {\r\n            const fakeInstanceFactories = this._fakeGenerator.generateFakeInstanceFactories(argumentType);\r\n            for(let fakeInstanceFactory of fakeInstanceFactories) {\r\n                this._registration.registerTypeAsInstanceFromAccessor(\r\n                    fakeInstanceFactory.type, \r\n                    fakeInstanceFactory.accessor);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport abstract class InversionOfControlRegistration {\r\n    abstract registerTypeAsInstanceFromAccessor(type: Constructor<any>, accessor: () => any): void;\r\n    abstract getConstructorArgumentTypesForClass<T extends Constructor>(type: T): Array<Constructor>;\r\n}\r\n\r\nexport abstract class FakeGenerator {\r\n    abstract generateFakeInstanceFactories<T extends Constructor>(type: T): Array<FakeInstanceFactory>;\r\n}\r\n\r\nexport class FakeInstanceFactory {\r\n    public get type() { return this._type; }\r\n    public get accessor() { return this._accessor; }\r\n\r\n    constructor(\r\n        private _type: Constructor,\r\n        private _accessor: () => any) \r\n    {\r\n        \r\n    }\r\n}"]}